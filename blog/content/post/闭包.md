---
title: 闭包
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["golang"]
tags: ["golang"]
---

# 闭包
#技术/golang

go语言中，函数是头等对象，可以做参数传递、函数返回值、绑定到变量。go语言称这样的参数、变量、返回值为function value。
函数的指令在编译时生成，而function value本质上是一个指针，但是并不直接指向函数指令入口，而是指向一个runtime.funcval结构体，这个结构体里只有一个地址，就是这个函数指令的入口地址。 

```
func A(i int) {
	i++
	fmt.Println(i)
}

func B() {
	f1 := A()
	f1(1)
}

func C() {
	f2 := A()
	f2(1)
}
```

这种情况，编译器会做出优化，让f1和f2共用一个funcval结构体。编译阶段在只读数据段分配一个funcval结构体fn指向函数A指令入口addr1，而它本身的起始地址addr2会在执行阶段赋给f1和f2。通过f1来执行函数，就会通过它存储的地址，找到对应的funcVal结构体，拿到函数入口地址，然后跳转执行。

```
栈 	|	
		|f1 = addr2
		|f2 = addr2
		|
		|
堆		-
		|
		|
addr2	| fn = addr1
		-
数据段	|
		|
		|
		|
代码段	-
		|
		|
		| addr1	
```
既然有函数地址就能调用，为什么要通过funcval结构体包装这个地址，然后使用一个二级指针来调用呢？这里主要是为了处理闭包的情况。
闭包的定义：
1. 自由变量：函数外部被定义，函数内部被使用
2. 脱离了形成闭包的上下文，闭包也能照常运行
```go
func create() func() int {
	c := 2
	return func() int {
		return c
	} 
}

func main() {
	f1 := create()
	f2 := create()
	fmt.Println(f1())
	fmt.Println(f2())
}
```
即使create()执行结束，通过f1和f2仍然能够正常调用这个闭包函数，并使用定义在create函数内部的局部变量c。通常称这个变量c为捕获变量。

闭包函数的指令自然也在编译阶段生成，但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。
每次调用create函数，会在堆创建一个funcval结构体以及捕获列表。先调用create()函数与f1绑定，这时会先创建一个funcval，地址为addr2；然后再调用create()函数与f2绑定，这时会再创建一个funcval，地址为addr3。
通过f1和f2调用闭包函数，就会找到各自对应的funcval结构体，拿到同一个函数入口。但是它们的捕获列表是不同的。
这就是称闭包为有状态函数的原因。
```
栈 	|	
		|f1 = addr2
		|f2 = addr3
		|
		|
堆		-
		| c = 2（捕获列表）
addr3	| fn = addr1
		|
		| c = 2（捕获列表）
addr2	| fn = addr1
		-
数据段	|
		|
		|
		|
代码段	-
		|
		|
		| addr1	
```
闭包函数如何找到捕获列表呢？
go语言中通过funcval调用函数时，会把对应的funcval结构体地址存入特定寄存器。这样在闭包函数中就可以通过寄存器取出funcval结构体的地址，然后加上相应的偏移来找到每一个被捕获的变量。
go语言中，闭包就是有捕获列表的funcval。没有捕获列表的funcval直接忽略偏移即可。

捕获列表不仅是拷贝变量值这么简单。被闭包捕获的变量，要在外层函数与闭包函数中表现一致，好像他们在使用同一个变量。
1. 被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以直接拷贝值到捕获列表中就OK了。
2. 如果除了初始化赋值外还被修改过，那就要再做细分。

```go
func create() (fs [2]func()) {
	for i := 0; i < 2; i++ {
		fs[i] = func() {
			fmt.Println(i)
		}
	}
	return
}

func main() {
	fs := create()
	for i := 0; i < len(fs); i++ {
		fs[i]()
	}
}
```

闭包函数指令入口地址addrf，main函数栈帧中，局部变量fs是一个长度为2的funcval数组。create函数栈帧，由于被闭包捕获，局部变量i改为堆分配，在栈上只存一个地址。第一次for循环，在堆上创建一个funcval结构体，捕获i的地址，这样闭包函数就和外层函数操作同一个变量了，第一次for循环结束，i自增1。第二次for循环开始，再次分配一个funcval，捕获变量i的地址，第二次循环结束，i自增1。此时i=2，满足循环退出条件，create函数结束，把返回值拷贝到局部变量fs。
通过fs[0]调用函数时，把addr0存入寄存器，闭包函数通过寄存器的存储的地址加上偏移，找到捕获变量i的地址。通过fs[1]调用时，把addr1存入寄存器，寄存器找到对应捕获变量的地址。被捕获的列表都指向堆上i=2的值，所以main函数每次都会打印2。
闭包导致的局部变量堆分配，也是变量逃逸的一种场景。
```
栈 	|	
		|addr1 	fs
		|addr0	fs
		|addr1 返回值
		|addr0 返回值
堆		-
		|
		| i = 2
		|
		| &i（捕获列表）
addr1	| fn = addrf
		|
		| &i（捕获列表）
addr0	| fn = addrf
		-
数据段	|
		|
		|
		|
代码段	-
		|
		|
		| addrf
```