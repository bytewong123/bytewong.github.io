---
title: 数据密集型应用系统设计
date: 2023-01-08T18:06:57+08:00
draft: false
categories: [""]
tags: [""]
---

# 数据密集型应用系统设计
#技术/读书笔记


## 关系模型与文档模型
1. 在关系模式中表示简历
可以把简历需要的字段拆分为多个表：
- 用户表
- 地区表
- 公司表
- 职位表
- 教育信息表
- 联系方式表
这几个表通过外键user_id和用户表关联在一起

2. 文档模式中表示简历
把简历作为一个json结构，每个用户的简历信息放在一个json文档中即可。职位、教育信息、地区等都是json的一个字段，层次清晰，扩展性好。

### 比较
#### 一对多关系
如果在关系模式中读取一份简历，要么执行多个查询（通过user_id查询多个表），要么在users表及其从属表之间执行混乱的多路联结。而对于json表示方法，所有相关的信息都在一个地方，一次查询就足够了。
用户简历到用户的职位、教育历史和联系信息存在一对多的关系，意味着数据存在树状结构。json表示将该树状结构显式化。
#### 多对一关系
对于简历这一例子，用户表的地区、职位、公司的值都为其对应的id，而不是文本，这样做有什么好处？
1. 避免歧义（同名城市、公司）
2. 易于更新：名字只保存一次，如果需要改变（例如政治事件），可以很容易全面更新
3. 本地化支持：当网站被翻译成其他语言时，可以用查看者的母语来显示。
使用id的好处是，它对人类没有任何直接意义，所以永远不需要直接改变：即使id代表的信息将来发生了变化，它也可以保持不变。任何对人类有意义的东西都可能在将来的某一时刻发生变更。
数据库规范化的核心思想就是消除重复，消除冗余。这种规范化通常是表达多对一的关系（多，但不需要多份复制，而是作为一个id被引用就好）比较适合关系模型，但不适用于文档模型。由于关系模型支持结联操作，可以方便地通过ID引用其他表中的行。而在文档数据库中，一对多的树状结构不需要结联，支持结联通常也很弱。
如果数据库本身不支持结联，则必须在应用程序代码中，通过对数据库多次查询来模拟结联。
即使应用程序的初始版本非常适合采用无结联的文档结构，但随着应用支持越来越多的功能，数据也变得更加互联一体化。

### 关系模型与文档模型的取舍
1. 如果应用数据具有类似文档的结构（一对多关系树，通常一次加载整个树），那么使用文档模型更合适；关系模型倾向于某种数据分解，它把文档结构分为多个表，有可能使得模式更为笨重，以及不必要的应用代码复杂化。
2. 在文档数据库中，对级联支持是否有问题取决于应用程序是否需要级联。如果确实使用了多对多关系，文档模型就变得不太吸引人。应用程序需要做额外的工作向数据库发出多个请求，模拟级联。这样会增加代码复杂度，并且速度比数据库的专用查询代码执行级联慢，在这些情况下，文档模型会导致应用程序代码更复杂，性能更差。
3. 文档模式更灵活，更适用于经常发生变化的数据结构；关系模式相对固定，修改字段比较困难。
4. 文档通常存储为编码的json、xml或其二进制变体（bson）的连续字符串。如果应用程序需要频繁访问整个文档，则存储局部性具有性能优势。如果数据被划分在多个表中，则需要进行多次索引来检索所有数据，中间可能需要更多的磁盘io并花费更多的时间。
局部性优势仅适用于需要同时访问文档大部分内容的场景。由于数据库通常会加载整个文档，如果应用只访问其中的一小部分，则对于大型文档数据来讲就有些浪费。对文档进行更新时，通常会重写整个文档，而只有修改量不改变源文档大小时，原地覆盖更新才更有效。因此，通常建议文档应该尽量小，且避免写入时增加文档大小。这些性能方面的不利因素大大限制了文档数据库的适用场景

### 文档数据库和关系数据库的融合
大多数关系数据库对xml，json提供了支持；一些文档数据库也开始提供级联，例如RethinkDB
### 命令式和声明式查询语言
命令式语言告诉计算机以特定顺序执行某些操作；
声明式查询语言指定所需的数据模式，结果需要满足什么条件，以及如何转换数据，而不需要指明如何实现这一目标

声明式查询语言比命令式查询语言更加简洁和易用。更重要的是它对外隐藏了数据库引擎的很多实现细节，这样**数据库能够在不改变查询语句的情况下提高性能**

声明式最大的好处：
1. 不用关系底层如何优化，在不改变查询语句的条件下，底层可以做更多优化的工作，只需要按照声明的内容将结果返回即可，命令式api是无法做到的，因为按什么样的顺序执行，完全是调用方决定，数据层能做的优化工作很少
2. 未来如果某些查询api改变了，命令式api可能会涉及到代码重写，而声明式api可以完全不用改变，由数据层进行兼容适配即可

### mapreduce查询
mapreduce是一种编程模型，用于在很多机器上批量处理海量数据，兴起于google。一些NoSQL存储系统（MongoDB和CouchDB）支持有限的mapreduce方式在大量文档上执行只读查询

mapreduce既不是声明式查询语言，也不是一个完全命令式的查询api，而是介于两者之间：查询的逻辑用代码片段表示，这些代码片段可以被处理框架重复地调用。

在pg中，可以这样表示：
```sql
SELECT date_trunc('month', ob_timestamp) AS ob_month, SUM(num_animals) AS total_animals FROM observations WHERE family = 'Sharks' GROUP BY ob_month;
```
此查询首先对观察结果进行过滤，只需要Sharks家族，然后按照他们的发现月份进行分组，最后将该月的所有观察动物数量求和汇总

MongoDB中的MapReduce功能也可以实现类似目的，如下所示：
```javascript
db.observations.mapReduce(
	function map() {
		var year = this.observationsTimestamp.getFullYear();
		var month = this.observationsTimestamp.getMonth()+1;
		emit(year + "-" + month, this.numAnimals);
	},
	function reduce(key, values) {
		return Array.sum(values);
	},
	{
		query:{family:"Sharks"},
		out:"monthlySharkReport"
	}
);
```
1. 过滤器声明式地指定鲨鱼种类：query
2. 对于每个匹配查询的文档，都会调用一次map函数，并将其设置为文档对象
3. map函数发射的键-值对按键分组。对于相同键（即相同的月份和年份）的所有键值对，调用reduce函数，reduce函数将特定所有观察到的动物数量相加

例如，map函数输出emit(“1995-12”, 3) 和 emit(“1995-12”, 4)，随后，reduce函数将被调用，reduce(“1995-12”, [3,4])，返回7

mapreduce的问题在于，编写两个js函数是有一定难度的；并且不利于查询优化器提供更多查询优化的机会，所以mongoDB增加了聚合管道的声明式查询语言的支持，能够达到和mapreduce一样的效果。

聚合管道在表达能力上相当于SQL的子集，但是它使用了基于JSON的语法，而不是SQL的英语句式语法。或许这种差异仅仅是个品味问题，然而这个故事的寓意是NoSQL系统可能会发现自己意外地重新发明了SQL，尽管是伪装的。