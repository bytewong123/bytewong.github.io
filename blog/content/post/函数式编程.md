---
title: å‡½æ•°å¼ç¼–ç¨‹
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["golang"]
tags: ["golang"]
---

# å‡½æ•°å¼ç¼–ç¨‹
#æŠ€æœ¯/golang/ä»£ç é£æ ¼

# å‡½æ•°å¼ç¼–ç¨‹çš„å¥½å¤„
**ä¸ºäº†æ›´å¥½çš„æ¨¡å—åŒ–**
* æ¨¡å—åŒ–ä½¿å¾—å¼€å‘æ›´å¿«ã€ç»´æŠ¤æ›´å®¹æ˜“

* æ¨¡å—å¯ä»¥é‡ç”¨

* æ¨¡å—åŒ–ä¾¿äºå•å…ƒæµ‹è¯•å’Œdebug

**Note**: å¹¶ä¸æ˜¯æ‰€æœ‰åœºæ™¯éƒ½é€‚åˆå‡½æ•°å¼ç¼–ç¨‹ï¼ï¼è¯»è¿‡ä¸€äº›å¼ºè¡Œä½¿ç”¨çš„ä»£ç ï¼Œéå¸¸èŠ±é‡Œèƒ¡å“¨ï¼Œå¯è¯»æ€§ä¸ºè´Ÿã€‚

# å‡½æ•°å¼ç¼–ç¨‹çš„æ€æƒ³
1. å‡½æ•°æ˜¯ç¬¬ä¸€ç­‰å…¬æ°‘ï¼Œæ”¯æŒé«˜é˜¶å‡½æ•°

2. çº¯å‡½æ•°

**é«˜é˜¶å‡½æ•°**ï¼ˆ [Higher Order Function](https://en.wikipedia.org/wiki/Higher-order_function) ï¼‰å¬èµ·æ¥å¾ˆé«˜å¤§ä¸Šï¼Œä½†å…¶å®æ¦‚å¿µä¹Ÿå¾ˆç®€å•ï¼šå¦‚æœä¸€ä¸ªå‡½æ•°æœ‰å‡½æ•°ç±»å‹çš„å‚æ•°ï¼Œæˆ–è€…è¿”å›å€¼æ˜¯å‡½æ•°ç±»å‹ï¼Œé‚£ä¹ˆè¿™ä¸ªå‡½æ•°å°±æ˜¯é«˜é˜¶å‡½æ•°ã€‚æœ¬ç¯‡æ–‡ç« çš„ DEMO ä¸»è¦å›´ç»•æ€æƒ³1ã€‚
# å®è·µ
# DEMO_1
### è¯‰æ±‚
*æœ‰æ•°ç»„list = [1,2,3]ï¼Œç¼–å†™ç¨‹åºå®Œæˆä»¥ä¸‹ç›®æ ‡ï¼š*
*- 1.1 å°†æ•°ç»„æ‰€æœ‰å…ƒç´ åŠ 1,å¹¶å¾—åˆ°æ–°æ•°ç»„*
*- 1.2 å°†æ•°ç»„æ‰€æœ‰å…ƒç´ å‡2,å¹¶å¾—åˆ°æ–°æ•°ç»„*
*- 1.3 â€¦.*
### å¸¸è§„å®ç°
```go
*// å°†æ•°ç»„æ‰€æœ‰å…ƒç´ åŠ 1,å¹¶å¾—åˆ°æ–°æ•°ç»„*
func f1(arr []int) []int {
   var newArr []int
   for _, num := range arr {
      newArr = append(newArr, num+1)
   }
   return newArr
}
*// å°†æ•°ç»„æ‰€æœ‰å…ƒç´ å‡2,å¹¶å¾—åˆ°æ–°æ•°ç»„*
func f2(arr []int) []int {
   var newArr []int
   for _, num := range arr {
      newArr = append(newArr, num-2)
   }
   return newArr
}

func main() {
   arr := []int{1, 2, 3}
   
   newArr1 := f1(arr)
   newArr2 := f2(arr)
}
```
### å‡½æ•°å¼æ”¹é€ 
```go
func Map(arr []int, fn func(num int) int) []int {
   var newArray []int
   for _, num := range arr {
      newArray = append(newArray, fn(num))
   }
   return newArray
}

func main() {
   a := []int{1, 2, 3}
   // *å°†æ•°ç»„æ‰€æœ‰å…ƒç´ åŠ 1,å¹¶å¾—åˆ°æ–°æ•°ç»„*
   newArr1 := Map(a, func(num int) int {
      return num +1
   })
   // *å°†æ•°ç»„æ‰€æœ‰å…ƒç´ å‡2,å¹¶å¾—åˆ°æ–°æ•°ç»„*
   newArr2 := Map(a, func(num int) int {
      return num -2
   })
}
```
**Note:** è¿™å…¶å®å°±æ˜¯åšäº†ä¸ª Map æ“ä½œï¼Œç†Ÿæ‚‰ JAVA çš„åŒå­¦éƒ½çŸ¥é“ï¼ŒJAVA ä¸­çš„ Mapã€Reduceã€Filter ç­‰é«˜é˜¶å‡½æ•°ä½¿ç”¨èµ·æ¥éå¸¸çš„èˆ’æœã€‚
# DEMO_2
### è¯‰æ±‚
*åˆ¤æ–­ä¸¤ä¸ªæµ®ç‚¹æ•°æ˜¯å¦ç›¸ç­‰ï¼š*
*- 1.1 ç²¾åº¦ä¿æŒåœ¨0.00001*
*- 1.2 ç²¾åº¦ä¿æŒåœ¨0.01*
- 1.3 
### å¸¸è§„å®ç°ä¸€
```go
const (
    a1 = 0.0001
    a2 = 0.01
)

func f1(a, b float64) bool {
    return math.Abs(a-b) < a1
}

func f2(a, b float64) bool {
    return math.Abs(a-b) < a2
 }
```
### å¸¸è§„å®ç°äºŒ
```go
func f1(a, b, accuracy float64) bool {
    return math.Abs(a-b) < accuracy
}
```
**Note:** è¿™æ ·ä¹Ÿè®¸å¯ä»¥ï¼Œä½†æ˜¯ç²¾åº¦ä¹ŸåšåŒçº§åˆ«å…¥å‚ä¼ å…¥ï¼Œæœ‰ç‚¹å¥‡æ€ªã€‚
### å‡½æ•°å¼æ”¹é€ 
```go
type Accuracy func() float64

func (this Accuracy) Equal(a, b float64) bool {
   return math.Abs(a-b) < this()
}

func main() {

   *// è®¾ç½®ç²¾ç¡®åº¦ä¸º0.00001*
var a1 Accuracy = func() float64 { return 0.00001 }
   a1.Equal(0.11111222, 0.11111222233333))
    *// è®¾ç½®ç²¾ç¡®åº¦ä¸º0.01*
   var a2 Accuracy = func() float64 { return 0.01 }
   a1.Equal(0.11111222, 0.11111222233333))
}
```
**Note:**Accuracyä¸æ˜¯ä¸€ä¸ªStructï¼Œæ˜¯ä¸€ä¸ªFunctionï¼Œå¹¶ä¸”åŸºäºå…¶ç»‘å®šMethodã€‚
# DEMO_3
### è¯‰æ±‚
èƒŒæ™¯: MySQLã€gorm
ç›®æ ‡: å·²çŸ¥userè¡¨ã€è¦æ±‚å¯ä»¥é€šè¿‡å„ä¸ªå­—æ®µåšæ•°æ®ç­›é€‰
```sql
CREATE TABLE `user_info` (
  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT â€˜è‡ªå¢ä¸»é”®â€™,
  `user_id` bigint NOT NULL COMMENT â€˜ç”¨æˆ·idâ€™,
  `user_name` varchar NOT NULL COMMENT â€˜ç”¨æˆ·å§“åâ€™,
  `role` int NOT NULL DEFAULT â€˜0â€™ COMMENT â€˜è§’è‰²â€™,
  `status` int NOT NULL DEFAULT â€˜0â€™ COMMENT â€˜çŠ¶æ€â€™,
  PRIMARY KEY (`id`),
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=â€˜ç”¨æˆ·ä¿¡æ¯è¡¨â€™;
```
### å¸¸è§„å®ç°
```go
type UserInfoSelectParams {
    UserID    int64
    Name      string
    Role      int32
    Status    int32
}

func GetUserInfo(ctx context.Context, p *UserInfoSelectParams) ([]*resource.UserInfo) {
   db := GetDB(ctx)
   db = db.Table(resource.UserInfo{}.TableName())
   var infos []*resource.UserInfo
   if p.UserID > 0 {
      db = db.Where(â€œuser_id = ?â€, info.UserID)
   }
   if p.Name != â€œâ€ {
      db = db.Where(â€œuser_name = ?â€, info.Name)
   }
   if p.Role > 0 {
      db = db.Where(â€œrole = ?â€, info.Role)
   }
   if p.Status > 0 {
      db = db.Where(â€œstatus = ?â€, info.Status)
   }
   db.Find(&infos)
   return infos
}
```
**Note:** è¿™æ˜¯æ¯”è¾ƒå¸¸è§çš„åšæ³•ï¼Œå»ºä¸€ä¸ªUserInfoSelectParamsç»“æ„ä½“ï¼ŒæŠŠå„ç§æŸ¥è¯¢çš„å­—æ®µéƒ½æ”¾åœ¨è¿™ä¸ªç»“æ„ä½“ä¸­ï¼Œè¿™æ ·éœ€è¦ä¸€äº›ç¹æ‚çš„IFåˆ¤ç©ºå’Œé¢å¤–å¼•å…¥ä¸€ä¸ªç»“æ„ä½“ã€‚
### å‡½æ•°å¼æ”¹é€ 
```go
type Option func(*gorm.DB)

func UserID(userID int64) Option {
   return func(db *gorm.DB) {
      db.Where(â€œ`user_id` = ?â€, userID)
   }
}
func UserName(name string) Option {
   return func(db *gorm.DB) {
      db.Where(â€œ`user_name` = ?â€, name)
   }
}

func Role(role int32) Option {
   return func(db *gorm.DB) {
      db.Where(â€œ`role` = ?â€, role)
   }
}

func StatusIn(status []int32) Option {
   return func(db *gorm.DB) {
      db.Where(â€œ`status` in ?â€, status)
   }
}

func GetUserInfo(ctx context.Context, options â€¦func(option *gorm.DB)) ([]*resource.UserInfo) {
   db := GetDB(ctx)
   db = db.Table(resource.UserInfo{}.TableName())
   for _, option := range options {
      option(db)
   }
   var infos []*resource.UserInfo
   db.Find(&infos)
   return infos
}

==========Example=================
// åªä½¿ç”¨userIDæŸ¥è¯¢
infos := GetUserInfo(ctx, UserID(userID))
//åªä½¿ç”¨userNameæŸ¥è¯¢
infos := GetUserInfo(ctx, UserName(name))
//ä½¿ç”¨roleå’ŒstatusåŒæ—¶æŸ¥è¯¢
infos := GetUserInfo(ctx, Role(role), Status(status))
```
**Note:**å…¥å‚æ˜¯ä¸€ä¸ªå­—æ®µçš„ç­›é€‰å€¼ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ª Option å‡½æ•°ï¼Œè€Œè¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æ˜¯æŠŠå…¥å‚èµ‹å€¼ç»™å½“å‰çš„[db *gorm.DB]å¯¹è±¡ï¼Œæ˜¾è€Œæ˜“è§çš„æ˜¯GetUserInfoå‡½æ•°æ— éœ€ä¸€ä¸ªä¸€ä¸ªçš„åˆ¤ç©ºï¼Œè€Œæ˜¯ç›´æ¥ä½¿ç”¨ä¸€ä¸ª for å¾ªç¯å°±æå®šï¼Œç›¸æ¯”ä¹‹å‰å·²ç»ç®€æ´äº†å¾ˆå¤šã€‚
# DEMO_4
ç­–ç•¥æ¨¡å¼ï¼šæ ¹æ®ä¸åŒç­–ç•¥æ¥æ‰§è¡Œå¯¹è±¡çš„ç›¸åº”æ“ä½œ
### è¯‰æ±‚
èƒŒæ™¯ï¼šåœ¨ä½¿ç”¨faaså¤„ç†äº‹ä»¶æ¶ˆæ¯çš„æ—¶å€™ï¼Œç»å¸¸ä¼šæ ¹æ®ä¸åŒäº‹ä»¶ç±»å‹æ¥åšä¸åŒçš„æ“ä½œã€‚
### å¸¸è§„å®ç°
```go
func EventHandler(ctx context.Context, event *eventbus_pb.Event) error {
 
   examEvent := &smart_scanner.ExamEvent{}
   if err := util.JSON.Unmarshal(event.Value, &examEvent); err != nil {
      logs.CtxError(ctx, â€œexam event unmarshal fail %vâ€, err)
      return err
   }

   switch examEvent.Type {
   case äº‹ä»¶1 :
   ä¸€å¨é€»è¾‘
   case äº‹ä»¶2 :
   ä¸€å¨é€»è¾‘
   case äº‹ä»¶3 :
   ä¸€å¨æ“ä½œ
   }
   
   return nil
}
```
### å‡½æ•°å¼æ”¹é€ 
```go
func EventHandler(ctx context.Context, event *eventbus_pb.Event) error {
 
   examEvent := &smart_scanner.ExamEvent{}
   if err := util.JSON.Unmarshal(event.Value, &examEvent); err != nil {
      logs.CtxError(ctx, â€œexam event unmarshal fail %vâ€, err)
      return err
   }
   
   f, ok := process.AcceptEventProcess[event.GetType()]
   if !ok {
      return nil
   }
   return f(ctx, event)
}

==========================================
type processor func(ctx context.Context, e *EduArkSmart_scanner.ExamEvent) error

var AcceptEventProcess = map[EduArkSmart_scanner.ExamEventType]processor{
   äº‹ä»¶1: å¤„ç†å‡½æ•°,
   äº‹ä»¶2: å¤„ç†å‡½æ•°,
}
```
**Note:** è¿™æ ·åšçš„å¥½å¤„ä¸ä»…æ˜¯è®© handler ä¸»ä½“å˜å¾—å¾ˆç®€æ´ï¼Œæœ€é‡è¦çš„æ˜¯**æ‰©å±•æ€§ä¸Šå¾—åˆ°äº†è´¨å˜**ï¼Œå› ä¸ºä½¿ç”¨äº†processorå‡½æ•°ç­¾åï¼Œè¿™æ ·å¾ˆå®¹æ˜“å»åµŒå¥—ä¸€äº›è£…é¥°å™¨ç­‰ç»Ÿä¸€æ“ä½œï¼Œä¸¾ä¸ªğŸŒ°ï¼Œå‡å¦‚è¦ç»™æ¯ä¸ªäº‹ä»¶çš„å¤„ç†æ“ä½œåŠ ç›‘æ§æ‰“ç‚¹ã€‚
```go
func metricsDecorator(p processor) processor {
    return func(ctx context.Context, e *EduArkSmart_scanner.ExamEvent) error{
    // ç›‘æ§æ‰“ç‚¹
    }
}
```
æ‰§è¡Œæ—¶å€™ï¼Œä»…éœ€è¦æŠŠä¸Šè¿° 13 è¡Œä»£ç ä¸­çš„f(ctx, event)æ›¿æ¢æˆmetricsDecorator(f)(ctx, event)ï¼Œå¦‚éœ€è¦è¿›è¡Œå…¶ä»–æ“ä½œå¯ä»¥æ— é™åµŒå¥—ï¼Œéå¸¸æ®‹å¿ã€‚
