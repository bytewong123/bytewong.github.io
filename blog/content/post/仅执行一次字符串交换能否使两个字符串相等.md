---
title: 仅执行一次字符串交换能否使两个字符串相等
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["算法"]
tags: ["算法"]
---

# 仅执行一次字符串交换能否使两个字符串相等
#算法/数组
## 题目
```
给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。

如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。

示例 1：

输入：s1 = "bank", s2 = "kanb"
输出：true
解释：例如，交换 s2 中的第一个和最后一个字符可以得到 "bank"
示例 2：

输入：s1 = "attack", s2 = "defend"
输出：false
解释：一次字符串交换无法使两个字符串相等
示例 3：

输入：s1 = "kelb", s2 = "kelb"
输出：true
解释：两个字符串已经相等，所以不需要进行字符串交换
示例 4：

输入：s1 = "abcd", s2 = "dcba"
输出：false
 

提示：

1 <= s1.length, s2.length <= 100
s1.length == s2.length
s1 和 s2 仅由小写英文字母组成
```
## 思路
1. 如果两个字符串相等，结束
2. 如果两个字符串不相等，找到不相等的位置，如果1没记录过，记录1；如果2没记录过，记录2
3. 因为最多只交换一次，即最多只有两个位置不一样；记录1、2如果都被记录了，说明有>2个位置不一样，交换一次是不能还原的，直接返回false
4. 最后比较记录1和记录2的位置在两个字符串中是否相等，相等则说明交换一次即可还原

## 答案
```go
func areAlmostEqual(s1 string, s2 string) bool {
    if len(s1) != len(s2) {
        return false
    }
    if s1 == s2 {
        return true
    }
    x, y := -1, -1
    for i := 0; i < len(s1); i++ {
        if s1[i] != s2[i] {
            if x == -1 {
                x = i
            } else if y == -1 {
                y = i
            } else {
                return false
            }
        }
    }
    return x != -1 && y != -1 && s1[x] == s2[y] && s1[y] == s2[x]
}
```