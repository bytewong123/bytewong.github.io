---
title: 网盘系统设计
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["系统设计"]
tags: ["系统设计"]
---

# 网盘系统设计
#技术/系统设计

## 需求
提供文件上传和下载服务。基于核心功能，需要在服务器端保存这些文件，并在下载和上传过程中实现断点续传。也就是说，如果上传或下载过程被中断了，恢复之后，还能从中断的地方重新上传或者下载，而不是从头再来

实现文件共享的需求。不同用户之间可以共享文件，一个用户上传的文件共享给其他用户后，其他用户也可以下载这个文件

网盘是一个存储和网络密集型的应用，用户文件占据大量硬盘资源，上传、下载需要占用大量网络带宽，并因此产生较高的运营成本。所以用户体验需要向付费用户倾斜。需要对上传和下载进行流速控制，保证付费用户得到更多的网络资源

## 概要设计
网盘设计的关键是元数据与文件内容的分离存储与管理。所谓文件元数据就是文件所有者、文件属性、访问控制这些文件的基础信息。

提供两个服务：
- API服务，对元信息进行读写
- 数据块Block服务，对对象存储读写的封装

对于大文件，DBox 不会上传、存储一整个的文件，而是将这个文件进行切分，变成一个个单独的 Block，再将它们分别上传并存储起来。这样做的核心原因是：
- DBox 采用对象存储作为最终的文件存储方案，而对象存储不适合存储大文件，需要进行切分。而大文件进行切分还带来其他的好处：可以以 Block 为单位进行上传和下载，提高文件传输速度；
- 客户端或者网络故障导致文件传输失败，也只需要重新传输失败的 Block 就可以，进而实现断点续传功能。
- Block 服务器就是负责 Block 上传和管理的。客户端应用程序根据 API 服务器的返回指令，将文件切分成一些 Block，然后将这些 Block 分别发送给 Block 服务器，Block 服务器再调用对象存储服务器集群，将 Block 存储在对象存储服务器中（DBox 选择 Ceph 作为对象存储）。

### 上传过程

- 用户上传文件时，客户端应用程序收集文件元数据，包括文件名、文件内容 MD5、文件大小等等，并根据文件大小计算 Block 的数量（DBox 设定每个 block 大小 4MB），以及每个 Block 的 MD5 值。
- 然后客户端应用程序将全部元数据（包括所有 Block 的 MD5 值列表）发送给 API 服务器。
- API 服务器收到文件元数据后，为每个 Block 分配全局唯一的 BlockID（BlockID 为严格递增的 64 位正整数，总可记录数据大小 264×4MB=180亿PB，足以满足 DBox 的应用场景）。
- API 服务器将文件元数据与 BlockID 记录在数据库中，并将 BlockID 列表和应用程序可以连接的 Block 服务器列表返回客户端。
- 客户端连接 Block 服务器请求上传 Block，Block 服务器连接 API 服务器进行权限和文件元数据验证。验证通过后，客户端上传 Block 数据，Block 服务器再次验证 Block 数据的 MD5 值，确认数据完整后，将 BlockID 和 Block 数据保存到对象存储集群 Ceph 中。

### 下载过程
- 客户端程序访问 API 服务器，请求下载文件。然后 API 服务器会查找数据库，获得文件的元数据信息，再将元数据信息中的文件 BlockID 列表及可以访问的 Block 服务器列表返回给客户端。
- 下一步，客户端访问 Block 服务器，请求下载 Block。Block 服务器验证用户权限后，从 Ceph 中读取 Block 数据，返回给客户端，客户端再将返回的 Block 组装为文件。

## 详细设计
### 元数据库设计
元数据库表结构中主要包括三个表，分别是 User 用户表、File 文件表和 Block 数据块表，表的用途和包含的主要字段如下

- User 用户表记录用户基本信息：用户名、创建时间、用户类型（免费、VIP）、用户已用空间、电话号码、头像等等。
- File 文件表记录文件元信息：文件名、是否为文件夹、上级文件夹、文件 MD5、创建时间、文件大小、文件所属用户、是否为共享文件等。
- Block 数据块表记录 Block 数据，包括 BlockID、Block MD5、对应文件等。

User 表和 File 表为一对多的关系，File 表和 Block 表也是一对多的关系

这 3 种表的记录数都是百亿级以上，所以元数据表采用分片的关系数据库存储。因为查询的主要场景是根据用户 ID 查找用户信息和文件信息，以及根据文件 ID 查询 block 信息，所以 User 和 File 表都采用 user_id 作为分片键（查询用户信息，查询用户有哪些文件），Block 表采用 file_id 作为分片键（查询某文件有哪些block）。

### 限速
根据用户付费类型决定用户的上传、下载速度。而要控制上传、下载速度，可以通过限制并发 Block 服务器数目，以及限制 Block 服务器内的线程数来实现。具体过程是，客户端程序访问 API 服务器，请求上传、下载文件的时候，API 服务器可以根据用户类型，决定分配的 Block 服务器数目和 Block 服务器内的服务线程数，以及每个线程的上传、下载速率。Block 服务器会根据 API 服务器的返回值，来控制客户端能够同时上传、下载的 Block 数量以及传输速率，以此对不同用户进行限速。

### 秒传
秒传是用户快速上传文件的一种功能。事实上，网盘保存的很多文件，内容其实是重复的，比如电影、电子书等等。一方面，重复上传这些文件会加大网盘的存储负载压力；另一方面，每次都要重新上传重复的内容，会导致用户网络带宽的浪费和用户等待时间过长的问题。

在设计中，物理上相同的文件，DBox 只会保存一份。用户每次上传文件时，DBox 都会先在客户端计算文件的 MD5 值，再根据 MD5 值判断该文件是否已经存在。对于已经存在的文件，只需要建立用户文件和该物理文件的关联即可，并不需要用户真正上传该文件，这样就可以实现秒传的功能。

计算 MD5 可能会发生 Hash 冲突，也就是不同文件算出来的 MD5 值是相同的，这样会导致 DBox 误判，将本不相同的文件关联到一个物理文件上。不但会使上传者丢失自己的文件，还会被黑客利用：上传一个和目标文件 MD5 相同的文件，然后就可以下载目标文件了。
所以，DBox 需要通过更多信息判断文件是否相同：只有文件长度、文件开头 256KB 的 MD5 值、文件的 MD5 值，三个值都相同，才会认为文件相同。当文件长度小于 256KB，则直接上传文件，不启用秒传功能。
为此，我们需要将上面的元数据库表结构进行一些改动，将原来的 File 表拆分成物理文件表 Physics_File 和逻辑文件表 Logic_File。其中，Logic_File 记录用户文件的元数据，并和物理文件表 Physics_File 建立多对 1 关联关系，而 Block 表关联的则是 Physics_File 表

physical文件不会在用户删除时立即删除，不管是不是有秒传关联。其次，网盘会定期清理垃圾文件，所以，physical文件需要有个引用计数器，每次有秒传关联，计数器+1，每次关联logical文件删除，计数器-1


