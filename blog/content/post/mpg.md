---
title: mpg
date: 2023-01-08T18:06:57+08:00
draft: false
categories: [""]
tags: [""]
---

# mpg
#iv/golang

- P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256，p的本地队列大小限制为256
- M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个
- G，相较于每个OS线程固定分配2M内存的模式，goroutine的栈采取了动态扩容方式初始时仅为2KB，随着任务执行按需增长，最大可达1GB（64位机器最大是1G，32位机器最大是256M），没有数量限制

- M是指machine，一个M直接关联了一个内核线程
- P是指processor，代表M所需的上下文，它负责衔接M和G的调度上下文，将等待执行的G与M对接，对G来说，P相当于CPU核
- G是指goroutine

调度过程：
1. 每个P维护一个G的本地队列
2. 当一个G被创建出来或者变为可执行状态时，就把它放到P的可执行队列中
3. 当一个G在M中执行结束，P会从队列中把它移出，若没了则从全局队列里取，若全局队列也没了则从别的P里偷，直接偷一半

协程阻塞场景
1. 系统调用阻塞
此时M可被抢占调度，执行G的M会与P解绑，P尝试与其他空闲的M绑定，继续执行其他G。如果没有空闲的M，但P的本地队列还有G需要运行，则创建一个新的M。当系统调用完成后，G会重新尝试获取一个空闲的P，进入它的本地队列，如果没有这样一个空闲的P，那么G将会被标记为runnable，加入到全局队列中。然后M将自己置于线程缓存中并进入休眠状态

2. 用户态阻塞
channel操作或network io阻塞
对应的G会被放到某个wait队列（例如channel的waitq）。M则会跳过该G尝试执行下一个G。如果此时没有可执行的G，M则解绑P并进入休眠状态。当阻塞的G被另一端的G2唤醒时，G被标记为runnable尝试加入G2所在P的run next。然后再是P的local队列，若P的local队列装不下了（达到256）则放入全局队列