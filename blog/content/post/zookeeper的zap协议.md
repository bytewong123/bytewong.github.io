---
title: zookeeper的zap协议
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["系统设计"]
tags: ["系统设计"]
---

# zookeeper的zap协议
#技术/系统设计
#技术/分布式理论

CAP 原理认为，一个提供数据服务的分布式系统无法同时满足数据一致性（Consistency）、可用性（Availibility）、分区耐受性（Patition Tolerance）这三个条件

- 其中，一致性的意思是，每次读取数据，要么读取到最近写入的数据，要么返回一个错误，而不是过期数据，这样就能保证数据一致。
- 可用性的意思是，每次请求都应该得到一个响应，而不是返回一个错误或者失去响应，不过这个响应不需要保证数据是最近写入的。也就是说，系统需要一直都能正常使用，不会引起调用者的异常，但是并不保证响应的数据是最新的。
- 分区耐受性的意思是，即使因为网络原因，部分服务器节点之间消息丢失或者延迟了，系统依然应该是可以操作的。

当网络分区失效发生时，要么我们取消操作，保证数据一致性，但是系统却不可用；要么我们继续写入数据，但是数据的一致性就得不到保证。
对于一个分布式系统而言，网络失效一定会发生，也就是说，分区耐受性是必须要保证的，那么可用性和一致性就只能二选一，这就是 CAP 原理。


三种角色
* **Leader** ：负责整个Zookeeper 集群工作机制中的核心，主要工作有一下两个：
	* 事务请求的唯一调度和处理者，保证集群事务处理的顺序性
	* 集群内部各服务器的调度者
* **Follower** ：它是 Leader 的追随者，其主要工作有三个：
	* 处理客户端的非实物请求，转发事务请求给 Leader 服务器
	* 参与事务请求 Proposal 的投票
	* 参与 Leader 选举投票
* **Observer** ：是 zookeeper 自 3.3.0 开始引入的一个角色，它不参与事务请求 Proposal 的投票，也不参与 Leader 选举投票，只提供非事务的服务（查询），通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。

Zookeeper 是如何知道自己目前是什么角色的呢？
在 ZAB 协议中定义：通过自身的状态来区分自己的角色的，在运行期间各个进程可能出现以下三种状态之一：
* **LOOKING**：处在这个状态时，会进入 Leader 选举状态
* **FOLLOWER**：Follower 服务器和 Leader 服务器保持同步时的状态
* **LEADING**：Leader 服务器作为主进程领导者的状态
在组成 ZAB 协议的所有进程启动的时候，初始化状态都是 LOOKING 状态，此时进程组中不存在 Leader，选举之后才有，在进行选举成功后，就进入消息广播模式，此时 Zookeeper 集群中的角色状态就不再是 LOOKING 状态。

## ZXID
前文我们知道 zookeeper 消息有严格的因果关系，因此必须将每一个事务请求按照先后顺序来进行排序与处理。那 Zookeeper 是如何保持请求处理的顺序的呢？其中非常关键的点就是 ZXID。
那 ZXID 究竟是怎么发挥作用的呢？
Leader 服务器在接收到事务请求后，会为每个事务请求生成对应的 Proposal 来进行广播，并且在广播事务 Proposal 之前，Leader 服务器会首先为这个事务 Proposal 分配一个全局单调递增的唯一 ID ，我们称之为事务 ID（即 ZXID）。
ZXID 的设计也很有特点，是一个全局有序的 64 位的数字，可以分为两个部分：
* 高 32 位是： epoch（纪元），代表着周期，每当选举产生一个新的 Leader 服务器时就会取出其本地日志中最大事务的 ZXID ，解析出 epoch（纪元）值操作加 1作为新的 epoch ，并将低 32 位置零。
* 低 32 位是： counter（计数器），它是一个简单的单调递增的计数器，针对客户端的每个事务请求都会进行加 1 操作；
这里低 32 位 counter（计数器）单调递增还好理解，高 32 位 epoch（纪元）每次选举加 1 也许有些同学就有疑问了，为什么 epoch（纪元）每次选需要举加 1 ，它在整个 ZAB 协议中有什么作用？
我们知道每当选举产生一个新的 Leader 服务器时生成一个新的 epoch（纪元）值，而在前文我们知道，服务运行过程中触发选举 Leader 的条件是：**Leader 服务器的出现网络中断、奔溃退出、重启等异常情况，或者当集群中半数的服务器与该 Leader 服务器无法通信时**。
这说明整个 Zookeeper 集群此时处于一个异常的情况下，而在发生异常前，消息广播进行到哪一步骤我们根本不知道，集群中的其他 Follower 节点从这种崩溃恢复状态重新选举出 Leader 后，如果老 Leader 又恢复了连接进入集群。此时老 Leader 的 epoch 肯定会小于新 Leader 的 epoch，这时就将老 Leader 变成 Follower，对新的 Leader 进行数据同步。即便这时老 Leader 对其他的 Follower 节点发送了请求，Follower 节点也会比较 ZXID 的值，因为高 32 位加 1 了， Follower 的 epoch（纪元）大于老 Leader 的 epoch（纪元），所以 Follower 会忽略这个请求。

## ZAB算法过程
**Zab 协议的特性**：
1）Zab 协议需要确保那些**已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交**。
2）Zab 协议需要确保**丢弃那些只在 Leader 上被提出而没有被提交的事务**。

ZooKeeper 则是一个保证数据一致性的分布式系统，它主要通过一个 ZAB 算法（Zookeeper Atomic Broadcast， Zookeeper 原子广播）实现数据一致性，算法过程如下：
- ZooKeeper 集群由多台服务器组成，为了保证多台服务器上存储的数据是一致的，ZAB 需要在这些服务器中选举一个 Leader，所有的写请求都必须提交给 Leader。
- Leader 服务器会向其他服务器（Follower）发起 Propose，通知所有服务器：“我们要完成一个写操作请求，请大家检查自己的数据状态是否有问题。”
- 如果所有 Follower 服务器都回复 Leader 服务器 ACK，即没有问题，那么 Leader 服务器会向所有 Follower 发送 Commit 命令，要求所有服务器完成写操作
- 当有超过半数的服务器 ACK 响应后，Leader 就会广播一个 Commit 消息给所有的 Follower 服务器，同时自身也会完成事务提交
- Follower 接收到Commit后就完成对事务的提交操作
- 实际应用中，客户端程序可以连接任意一个 Follower，进行数据读写操作。如果是写操作，那么这个请求会被 Follower 发送给 Leader，进行如上所述的处理；如果是读操作，因为所有服务器的数据都是一致的，那么这个 Follower 直接把自己本地的数据返回给客户端就可以了

## 最终一致性、顺序一致性
- 最终一致性
zookeeper使用的ZAB协议进行主从数据同步，ZAB协议认为只要是过半数节点写入成为，数据就算写成功了，然后会告诉客户端A数据写入成功，如果这个时候客户端B恰好访问到还没同步最新数据的zookeeper节点，那么读到的数据就是不一致性的，因此zookeeper无法保证写数据的强一致性，只能保证最终一致性，而且可以保证同一客户端的顺序一致性
- 顺序一致性
ZXID的低32位是计数器，所以同一任期内，ZXID是连续的，每个结点又都保存着自身最新生效的ZXID，通过对比新提案的ZXID与自身最新ZXID是否相差“1”，来保证事务严格按照顺序生效的。如果当前新提案的ZXID前有未提交的ZXID，那么无法提交

## 选举
当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。

**新选举出来的 Leader 不能包含未提交的 Proposal** 。
即新选举的 Leader 必须都是已经提交了 Proposal 的 Follower 服务器节点。
**新选举的 Leader 节点中含有最大的 zxid** 。
这样做的好处是可以避免 Leader 服务器检查 Proposal 的提交和丢弃工作。

## 保证消息有序
在整个消息广播中，Leader会将每一个事务请求转换成对应的 proposal 来进行广播，并且在广播 事务Proposal 之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个proposal按照其zxid的先后顺序进行排序和处理。

