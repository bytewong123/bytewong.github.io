---
title: 数组中只出现一次的数字，其余数字出现3次
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["算法"]
tags: ["算法"]
---

# 数组中只出现一次的数字，其余数字出现3次
#算法/位运算
#算法/仍然不会

1. 如果某个数组中，有一个数字只出现了一次，其余数字出现了3次，那么把所有数字的每一位相加，只有1位不能被3整除，其余位均可以被3整除。因为有1位会多一个1，这个就是只出现1次的那个数字造成的。
2. 显然，如果相加后的每一位，只要是不能被3整除，那么唯一的那个数字在那一位必然为1。
3. 找出所有不能被3整除的位，说明唯一的那个数字在这些位上都为1，将其还原为十进制即可

```go
func singleNumber(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
	  //int类型至少32位，根据编译器不同而不同；
 	  //创建一个位数组，每一位存储所有原数组中各个位的加和
    bits := make([]int, 32)
	  //开始计算各个位的加和
    for _, num := range nums {
        n := num
        for j := 31; j >= 0; j-- {
            //整数化为二进制，低位到高位是从右往左的，因此数组也从右往左赋值
			  //即从31往0走
			  //最右侧的位与1求且运算
			  //每求一次，原数字往右移动1位，这样让每1位都能与1求且运算，可以反映出该位是否为1，结果放入不断左移的位数组
            bits[j] += (n & 1)
            n = (n >> 1)
        }
    }
    ans := 0
    bit := 0
    for i := 31; i >= 0; i-- {
		  //检查位数组不能被3整除的位，说明该位为1，将其还原为十进制
        if bits[i] % 3 != 0 {
            ans += (1 << bit)
        }
        bit++
    }
    return ans
}
```
时间复杂度：遍历了nums数组1次；遍历了位数组两次，其中一次在nums遍历过程中遍历，常数次，O(n)
空间复杂度，O(32)，常数，因此为O(1)

方法二，hash法。时间空间复杂度均为O(n)