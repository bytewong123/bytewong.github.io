---
title: mysql知识点汇总——mvcc
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["mysql"]
tags: ["mysql"]
---

# mysql知识点汇总——mvcc
#技术/数据库/mysql

## 适用mvcc的隔离级别
- RC：视图在每个SQL语句开始执行时创建，因此一个事务中多个SQL语句执行会有多个视图
- RR：视图是在事务启动时创建，整个事务存在期间都使用这个视图

## mvcc的实现机制
### 快照如何实现
1. InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
2. 每行数据有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。
3. undo log：每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值
4. read-view
- read-view实现机制
	1. 活跃事务数组：启动了但还没提交的所有事务id数组
	2. 低水位：活跃事务数组中的最小值
	3. 高水位：已创建过的所有事务最大值+1
	通过如上三个要素，可以将所有的row trx_id分成三种情况
		1. 已提交事务：小于低水位的事务，可见
		2. 未开始事务：大于高水位的事务，不可见
		3. 中间部分：
			1. 启动了但还没提交的所有事务id数组，如果row trx_id在数组中，说明还没提交，不可见
			2. row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见
> 总结：
> 一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：
> 版本未提交，不可见；
> 版本已提交，但是是在视图创建后提交的，不可见；
> 版本已提交，而且是在视图创建前提交的，可见。

5. 更新数据
	- 更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read），除了 update 语句外，select 语句如果加锁，也是当前读
> 下面这两个 select 语句，就是分别加了读锁（S 锁，共享锁）和写锁（X 锁，排他锁）
> mysql> select k from t where id=1 lock in share mode;
> mysql> select k from t where id=1 for update;

	- 可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。即mvcc的实现机制与锁不冲突，仍然需要使用到锁的能力

	- 假设事务a启动后，事务b启动了，执行了1000000次更新某id对应的某个字段。在事务a中使用带 lock in share mode 的 SQL 语句，是当前读，因此会直接读到 1000001 这个结果，所以速度很快；而 select * from t where id=1 这个语句，是一致性读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后，才将 1 这个结果返回。
