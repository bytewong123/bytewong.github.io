---
title: 数组中两个只出现一次的数字
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["算法"]
tags: ["算法"]
---

# 数组中两个只出现一次的数字
#算法/位运算
#算法/仍然不会

思路：
基础：
1. 两个数异或运算，相同的位结果为0，不同的位结果为1
2. 0和任何数异或，因为若该数的位为1，异或后还是为1，若该数的位为0，异或后还是为0，即0与任何数异或的结果为任何数
3. 如果两个数相同，它们进行异或操作，位都相同，所以结果为0
异或满足交换律，结合律

针对一个数组中，如果只有一个数字出现了一次，其余的数字都出现了两次，那么把整个数组的数字全部进行异或操作，所得的答案即为剩下那个不同的数

如果除两个数字之外，其他数字都出现了两次，即本题，那么无法使用全体异或法了。
1. 先全体异或，得到一个答案。这个答案是最终两个不同数的异或结果，若将其拆解为位，那么为1的位代表两数不同的位。
2. 我们需要将数组分组为两组，两个不同的数要分在不同的组，这样对两组分别整体异或即为答案。
3. 如何分组呢，之前整体异或得到的答案，我们需要找到为1的那一位，这样数组中的数与为1的那一位去求且运算，这样就能将两个不同的数分到不同的组了
4. 且运算为0，即各位都与异或结果不相等，分到一组；非0，分到一组；

系列题解：
[力扣](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/solution/zhi-chu-xian-yi-ci-de-shu-xi-lie-wei-yun-suan-by-a/)

```go
func singleNumbers(nums []int) []int {
    ret := 0
    for i := 0; i < len(nums); i++ {
        ret ^= nums[i]
    }
    mask := 1
    for {
       if mask & ret == 0 {
           mask = mask << 1
       } else {
           break
       }
    }
    a, b := 0, 0
    for i := 0; i < len(nums); i++ {
        if (nums[i] & mask) != 0 {
            a ^= nums[i]
        } else {
            b ^= nums[i]
        }
    }
    return []int{a, b}
}
```