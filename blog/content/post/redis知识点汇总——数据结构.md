---
title: redis知识点汇总——数据结构
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["redis"]
tags: ["redis"]
---

# redis知识点汇总——数据结构
#技术/数据库/redis

## string
string有三种数据类型：
- int（数字，如果可以用long表示，则为int）
- raw
- embstr（若字符串长度<=39字节使用embstr方式保存这个字符串值。raw编码会调用两次内存分配函数来分别创建redisObject和sdshdr结构，而embstr只需要调用一次 ，分配一块连续的空间依次创建这两个结构；释放同理；embstr保存在一块连续内存中，raw不是）

### sds
数据结构：sds
- 用于存放浮点、字符、字节类型
- 数据结构：
```c
typedef struct sdshdr {
    // buf中已经占用的字符长度
    // '\0'不包含在其中
    unsigned int len;
    // buf中剩余可用的字符长度
    unsigned int free;
    // 数据空间
    char buf[];
}
```
- 特性：
空间预分配
	- 如果修改后len长度将小于1M,这时分配给free的大小和len一样,例如修改过后为10字节, 那么给free也是10字节，buf实际长度变成了10 + 10 + 1 = 21byte
	- 如果修改后len长度将大于等于1M,这时分配给free的长度为1M,例如修改过后为30M,那么给free是1M.buf实际长度变成了30M + 1M + 1byte
惰性空间释放
	- 惰性空间释放指的是当字符串缩短时，并没有真正的缩容，free值增大了，这样将来字符串长度增加时，就不用重新分配内存了。但这样会造成内存浪费，Redis提供了API来真正释放内存。
- 特点：
	1. 获取字符串长度的复杂度为O(1)
	2. 二进制安全，redis是使用len来判断字符串是否结束而不是通过\0空字符来判断字符串结束，c因为是通过\0来判断字符串结束的，所以不能存储一些二进制数据（有可能中间有\0，导致数据在中间就被截断了），而redis的sds是通过len来判断字符串结束的。
	3. sds 会减少修改字符串时带来的内存重分配次数：加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。
		- 空间预分配
		- 惰性空间释放
	4. 杜绝缓冲区溢出：例如c语言字符串执行strcat(dest, src)，将src追加到dest末尾，若执行前没有给dest分配足够的空间，可能会覆盖别的内存中的数据；sds会先检查空间是否满足修改所需的要求，不满足的话会扩容，然后再执行修改操作
	5. 仍然在字符串末尾保留了c语言的空字符，这是为了兼容部分c字符串函数，避免编写与c功能重复的函数

## hash
hash内部有两种实现，ziplist和hashtable

### ziplist
#### 特点：
1. 类似数组，通过一片连续的内存空间来存储数据
2. 跟数组不同的一点是，它允许存储的数据大小不同。每个节点上增加一个length属性来记录这个节点的长度，这样比较方便地得到下一个节点的位置
#### 数据结构
1. zlbytes：列表的字节数
记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 zlend的位置时使用
2. zltail：到最末尾的偏移
记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址
3. zllen：元素的个数
记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。
4. entry：元素的内容，里面记录了前一个Entry的长度，用于方便双向遍历
数据结构：
- previous_entry_length
	- 前一个节点的长度，前一节点的长度小于254字节，则previous_entry_length长度为1字节（因为1字节是8位，最大值11111111，代表的十进制数位255，超过这个数就存不下了）
	- 前一节点的长度大于等于254字节，则previous_entry_length长度为5字节
- encoding
	- 数据类型
	- length，长度
- content
具体数据的内容

连锁更新问题：
	1. 插入引发的连锁更新：
	- e1,e2,...,en的长度都为250-253字节，previous_entry_length只需要1字节长
	- 现在插入一个长度大于等于254字节的节点至头节点，变为了e1的前置节点，因此e1的pel需要5字节，此时，e1的长度需要增加4字节，变为了254-257字节之间；为了让e2能保存e1的长度，因此e2的长度也需要增加4字节；e3也需要增加4字节来保存e2的长度... ...
	2. 删除引发的连锁更新：
	- e1节点长度为254字节，e2,e3,...,en长度为250-253字节
	- 删除e2节点，e3为了能容纳e1，需要增加4字节，之后的e4,e5...也是如此，依次扩容

5. zlend：恒为0xFF，作为ziplist的定界符
特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端

### hashtable
使用hash表作为底层实现
#### 数据结构
hashtable数据结构：
1. hash表节点：
	1. key
	2. value
	3. next指针，指向下一个hash表节点的指针，将多个hash值相同的键值对连接在一起，形成链表，解决hash冲突
2. hash表大小size
3. hash表大小掩码，用于计算索引值
4. hash表已有节点数量used

整体结构：
- 长度为2的hash表数组
	- 第0项，保存数据的字典
	- 第1项，字典进行rehash时使用
- rehashidx，如果没有进行rehash，它的值为-1

#### 细节
- 当hash产生冲突时，将新节点添加到链表的表头位置
- rehash的时机
> hash表已保存节点数量/hash表大小
	- 扩容
		- 服务器没有执行bgsave或bgrewriteaof，且hash表的负载因子>=1
		- 服务器正在执行bgsave或bgrewriteof，且hash表的负载因子>=5
	- 缩容
		- 负载因子<0.1时，会自动对hash表执行缩容操作
- rehash的步骤
	1. 为ht[1]分配空间
		1. 如果是扩展操作，ht[1]的大小为第一个>=ht[0].used*2的2^n
		2. 如果是收缩操作，ht[1]的大小为第一个>=ht[0].used的2^n
	2. 将ht[0]的所有键值对rehash到ht[1]上面：rehash是指重新计算键的hash值和索引值，然后将键值对放置到ht[1]的hash表的指定位置上
	3. 当ht[0]包含的所有键值对都迁移到ht[1]后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]创建一个空的hash表，为下一次rehash做准备
- 渐进式rehash
	1. 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个hash表
	2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示开始rehash原hash表中的第0项中的链表
	3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增1
	4. 当第0项rehash完成后，rehashidx++，直到原hash表中所有索引项都rehash完成，此时将rehashidx设置为-1
	5. 在rehash期间：
		1. 查找：先在ht[0]中查找，若没找到则在ht[1]中查找
		2. 添加：新添加的键值对一律被保存在ht[1]中，ht[0]中不再进行任何添加操作

## list
list有两种实现，ziplist和linkedlist

### linkedlist
链表
1. 双向链表：
	1. 表头节点
	2. 表尾节点
	3. 链表包含的节点数量
2. 特性：
	1. 双向链表，获取前置和后置节点的时间复杂度都是O(1)
	2. 无环，头节点和尾节点都指向NULL
	3. 带表头和表尾节点，访问表头节点和表尾节点的时间复杂度都是O(1)
	4. 带链表长度计数器，O(1)复杂度获取链表中节点数量

## set
set有两种实现，intset和hashtable

### intset
当一个集合只包含整数值元素，并且这个集合的元素数量不多时，redis就会使用整数集合作为set的底层实现

#### 数据结构
1. encoding，编码方式
2. length集合，包含的元素数量，即contents数组的长度
3. []contents，保存元素的数组，各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项

#### 升级
当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后再能将新元素添加到整数集合里面

步骤：
1. 根据新元素的类型，扩展整数集合底层空间大小（还需加上为新元素分配的空间大小）
2. 将底层数组现有的所有元素都转换成与新元素相同的类型
3. 移动现有元素，将其放在正确的索引位置上
4. 将新元素添加到底层数组里面
	1. 因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大，所以这个新元素的值要么就大于所有现有的元素，要么就小于所有现有的元素。小于：放在底层数组的最开头；大于：放在底层数组的最末尾。

#### 降级
整数集合不支持降级操作


## zset
zset有两种实现，ziplist和skiplist

### skiplist
跳表
#### 特点：
1. 支持平均O(logN)，最坏O(N)的复杂度节点查找
2. 效率可以和平衡树相媲美，实现更简单
3. 只在zset数据结构和集群节点中作为内部数据结构中使用
#### 数据结构
Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针

跳跃表节点：
1. 后退指针：后退指针一次只能后退一个节点
2. score：double 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序
3. obj：指针， 它指向一个字符串对象
4. level数组：
	1. 指向其他节点的前进指针
	2. span跨度，用于记录两个节点之间的距离，用于计算排位，在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位
每次新创建一个跳跃表节点的时候，程序都根据幂次定律（越大的数出现的概率越小）随机生成一个1~32之间的值作为level数组的大小，这个大小就是层的高度