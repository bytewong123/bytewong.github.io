---
title: mysql知识点汇总——索引
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["mysql"]
tags: ["mysql"]
---

# mysql知识点汇总——索引
#技术/数据库/mysql

## 常见的数据结构
- hash索引
不能支持范围查询
- 二叉查找树
极端情况下退化为链表（顺序插入时）
- 平衡二叉树
每一个树的节点只存储了一个数据，一次磁盘io只能从取出一个节点上的数据加载到内存中
- b树索引与b+树
区别：
	- b树的每个节点都有data元素，b+树把data元素放到了叶子节点
	- b+树的叶子节点有双向指针
	- b+树叶子节点包含所有索引字段
b+树比b树的优势：
	- 非叶子节点不存储data，只存储索引，在树高相同的情况下b+树能存放更多元素；b树想存放相同数量元素，需要更高的树高
	- b+树的叶子节点是双向链表，能很好地支持范围查找；b树不能很好支持范围查找

## 存储引擎
### innodb
innodb数据文件和索引文件不是分离的
	- frm文件：表结构文件
	- ibd文件：索引+数据文件
#### 聚簇索引
innodb的主键索引是聚集索引；一张表只能有一个聚簇索引。
聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分，每张表只能拥有一个聚簇索引
1. innodb必须有主键。若没有显式指定，会从第一列开始，选择可以建唯一索引的列（无重复），将这一列作为主键索引来维护；
2. 若找不到这样的列，会建一个隐藏列作为主键索引。
3. innodb建议用整型自增主键：
	1. b+树定位元素会多次比大小，整型好比较大小
	2. 整型更节省空间
	3. 自增：插入元素时，若自增，只需在最后一层节点向后插入即可，若不自增，有可能导致前面排好序的节点分裂，平衡，使插入效率变低
	4. 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小
有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：
1. 只有一个索引；
2. 该索引必须是唯一索引。
你一定看出来了，这就是典型的 KV 场景。由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。这时候我们就要优先考虑“尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。

索引下推：
在“仅能利用最左前缀索的场景”下（而不是能利用全部联合索引），对不在最左前缀索引中的其他联合索引字段加以利用——在遍历索引时，就用这些其他字段进行过滤(where条件里的匹配)。过滤会减少遍历索引查出的主键条数，从而减少回表次数，提示整体性能。
如果不使用索引下推，就需要对回表时对其余字段进行判断过滤。而索引下推在有些行如果包含了条件的部分字段，就可以在此时先进行一下过滤。

#### 非聚簇索引
非主键索引不存储完整的数据，只存储了主键，然后需要到主键索引中去得到完整的数据，性能不如主键索引。

#### 唯一索引
聚簇索引是一种特殊的唯一索引。唯一索引允许NULL值，聚簇索引不允许。

#### 覆盖索引
主键的值已经在二级索引的叶子节点上了，因此如果有通过二级索引查询主键的需求，就可以直接返回结果，而不用再回表到聚簇索引进行查询；


### myisam
myisam数据文件和索引文件是分离的：
- frm文件：表结构文件
- myi文件：索引文件
- myd文件：数据文件
检索方式：检查查询条件是否命中索引，若命中则去myi文件查找该记录的叶子节点，若命中则去myd文件取得真实数据


## 普通索引和唯一索引的性能分析
### 查询性能
InnoDB 的数据是按数据页为单位来读写的。当找到 索引所需记录的时候，它所在的数据页就都在内存里了。那么，对于普通索引来说，要多做的那一次“查找和判断下一条记录”的操作，就只需要一次指针寻找和一次计算。当然，如果 k=5 这个记录刚好是这个数据页的最后一个记录，那么要取下一个记录，必须读取下一个数据页，这个操作会稍微复杂一些。对于整型字段，一个数据页可以放近千个 key，出现这种情况的概率比较小。
因此，在查询性能分析中，普通索引和唯一索引的区别不大。
### 更新性能
当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。
将 change buffer 中的操作应用到原数据页，得到最新结果的过程称为 merge。除了访问这个数据页会触发 merge 外，系统有后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会执行 merge 操作。
显然，如果能够将更新操作先记录在 change buffer，减少读磁盘，语句的执行速度会得到明显的提升。而且，数据读入内存是需要占用 buffer pool 的，所以这种方式还能够避免占用内存，提高内存利用率。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。

因此，唯一索引的更新就不能使用 change buffer，实际上也只有普通索引可以使用。将数据从磁盘读入内存涉及随机 IO 的访问，是数据库里面成本最高的操作之一。change buffer 因为减少了随机磁盘访问，所以对更新性能的提升是会很明显的。
假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在 change buffer，但之后由于马上要访问这个数据页，会立即触发 merge 过程。这样随机访问 IO 的次数不会减少，反而增加了 change buffer 的维护代价。所以，对于这种业务模式来说，change buffer 反而起到了副作用。

总结：
1. 其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，建议尽量选择普通索引。
2. 如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。

> redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗（更新时不用将磁盘中的数据读出来）。
