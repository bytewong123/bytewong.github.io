---
title: gc总结
date: 2023-01-08T18:06:57+08:00
draft: false
categories: ["golang"]
tags: ["golang"]
---

# gc总结
#技术/golang/gc

# 常见的GC算法
1. 引用计数法
根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。
* **优点**：简单直接，回收速度快
* **缺点**：需要额外的空间存放计数，无法处理循环引用的情况；

2. 标记清除法
标记出所有不需要回收的对象，在标记完成后统一回收掉所有未被标记的对象。 [image:1A52A1DE-6520-428D-9854-9583FFCA470E-49645-0000A3D25675E408/1608188427502_de9df244bd7b6263abf7a5ccb80659b9.png]
* **优点**：简单直接，速度快，适合可回收对象不多的场景
* **缺点**：会造成不连续的内存空间（内存碎片），导致有大的对象创建的时候，明明内存中总内存是够的，但是空间不是连续的造成对象无法分配；

3. 复制法
复制法将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉 [image:B5DB9C40-2C26-4C81-9B97-D0E4A750DAA9-49645-0000A3D2563FFF7A/1608188507950_431681cdeef89a6f3903ed832696cb9d.png]
* **优点**：解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；
* **缺点**：有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；

4. 标记整理
标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容。 [image:35D1F78F-83DB-4B30-8F0B-5022F639F806-49645-0000A3D255FC6C6F/1608188518331_fe62c7a6a688269cb5815983a718ba2a.png]
* **优点**：解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用；
* **缺点**：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；

5. 分代式
将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。

# go的GC算法
Golang GC 算法使用的是无无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。原因在于：
* 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 **tcmalloc**，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 **tcmalloc** 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
* 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。
